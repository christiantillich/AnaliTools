{
    "contents" : "require(plyr)\nrequire(dplyr)\nrequire(ggplot2)\n\n\n\n.buckets <- function(x,\n  num.switch = class(x) %in% c(\"numeric\", \"integer\", \"float\")\n )\n {\n  #If the variable is numeric and the switch is okay,\n  if(num.switch){\n\n    #Use the histogram function to get the groupings\n    groups <- hist(x, plot=F)$breaks\n\n    #Use the cute sapply stuff to do the lookup.\n    buckets <- sapply(x, function(a) groups[which.min(abs(groups - a))])\n\n  }else{\n  #If the variable is non-numeric, or the switch has been thrown.\n\n    #If the variable has thirty or fewer unique values\n    if(length(unique(x)) < 30){\n\n      #The groupings are simply unique values as a character vector.\n      groups <- unique(x)\n\n      #The buckets are simply a character conversion of the vector.\n      buckets <- x\n\n    }else{\n    #If the variable has more than thirty unique values\n\n      #Take the first 29 most frequent values\n      n <- table(x)[x %>% table() %>% order(decreasing = T)] %>% head(29) %>% names\n\n      #Groupings are those 29 plus \"other\" category\n      groups <- c(n, \"Other\")\n\n      #Buckets are the vector, where the non-grouped are changed to Other.\n      buckets <- x; buckets[!buckets %in% n] <- \"Other\"\n    }\n  #Return the buckets and the groupings.\n  }\n  return(list(groups=groups, buckets=buckets))\n}\n# .buckets(iris[,1], F)\n# .buckets(iris[,2])\n\n\n\n\nperf.plot <- function(y, x\n  ,xlab = deparse(substitute(x))\n  ,ylab = deparse(substitute(y))\n  ,main = paste(ylab, xlab, sep=\" vs. \" )\n  ,num.switch = class(x) %in% c(\"numeric\", \"integer\", \"float\")\n  ,col = 'black'\n  ,lwd = 450/length(.buckets(x, num.switch)$groups)\n  ){\n\n  #Makes the x-axis groupings for the variable.\n  groups <- .buckets(x, num.switch)$groups\n  buckets <- .buckets(x, num.switch)$buckets\n\n\n  #This is the main data manipulation step. Gets summary stats by bucket.\n  t <- data.frame(x, buckets, y) %>%\n    group_by(buckets) %>%\n    summarise(count = n(), avg = mean(y)) %>%\n    merge(as.data.frame(groups), by.x=\"buckets\", by.y=\"groups\", all.y=T) %>%\n    mutate(\n       count = replace(count, is.na(count), 0)\n      ,avg = replace(avg, is.na(avg), 0)\n      )\n\n  #Plot the data from the modified summary data frame\n#   plot(t$count\n#     ,type='h'\n#     ,lwd = lwd,\n#     ,lend='square', col='grey'\n#     ,xaxt='n', yaxt='n', ylab='', xlab=''\n#     )\n#   axis(side=1, labels=t$buckets, at=1:nrow(t), las=2)\n#   axis(side=4, at=pretty(t$count), labels=T)\n#   par(new=TRUE)\n#   plot(t$avg,\n#      type = 'b', col=col,\n#      xaxt='n',xlab = xlab, ylab = ylab,\n#      main = main\n#     )\n\n  qplot(\n     buckets\n    ,avg\n    ,data=t\n    ,geom= if(num.switch){\"line\"} else{\"point\"}\n    ,color=I(col),xlab = xlab,ylab = ylab,main=main\n  ) + geom_histogram(\n         aes(y=count * max(abs(avg))/max(count))\n        ,stat=\"identity\"\n        ,fill=I(\"grey\")\n        ,origin = 10\n      ) +\n      geom_histogram(\n         aes(y= if(min(avg) < 0) {-count * max(abs(avg))/max(count)} else{0})\n        ,stat=\"identity\"\n        ,fill=I(\"grey\")\n        ,origin = 10\n      ) + theme_BA +\n      geom_point(aes(y=avg), color=I(col)) +\n      if(num.switch){\n        geom_line(aes(y=avg), color=I(col))\n      }\n\n}\n\n\n# perf.plot(as.integer(iris$Species == \"virginica\"),iris[,1])\n# perf.plot(as.integer(iris$Species == \"virginica\"),iris[,2])\n# perf.plot(as.integer(iris$Species == \"virginica\"),iris[,3])\n# perf.plot(as.integer(iris$Species == \"virginica\"),iris[,1], num.switch=F)\n# perf.plot(as.integer(iris$Species == \"virginica\"),iris[,3], num.switch=F)\n\n#TODO: Add some data to test that's negative.\n",
    "created" : 1449601361107.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2058111852",
    "id" : "D31EE076",
    "lastKnownWriteTime" : 1449601446,
    "path" : "~/AnaliTools/R/perf.plot.R",
    "project_path" : "R/perf.plot.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}